<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>総合成績 / 個人成績</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      background-color: #f0f0f0;
      padding: 20px;
      margin: 0;
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
    }
    .filter-box {
      max-width: 500px;
      margin: 10px auto;
      text-align: center;
    }
    .filter-box input {
      margin: 5px;
      padding: 8px;
      font-size: 14px;
    }
    .main-button {
      display: block;
      width: 100%;
      max-width: 300px;
      margin: 20px auto;
      padding: 15px;
      font-size: 18px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    .table-wrapper {
      overflow-x: auto;
      margin-top: 20px;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      background: white;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 10px;
      text-align: center;
    }
    th {
      background-color: #e0e0e0;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    th:first-child, td:first-child {
      position: sticky;
      left: 0;
      background: #ffffff;
      z-index: 2;
      font-weight: bold;
      box-shadow: 2px 0 5px rgba(0,0,0,0.1);
    }
    .highlight-max { background-color: #d0e7ff; }
    .highlight-min { background-color: #ffdede; }
    .clickable-name {
      cursor: pointer;
      color: #007bff;
      text-decoration: underline;
    }
    .player-detail {
      background-color: #e6f4ea;
      padding: 15px;
      border-radius: 8px;
      margin-top: 20px;
    }
    canvas {
      margin-top: 20px;
      max-width: 100%;
    }
  </style>
</head>
<body>
  <h1>総合成績 / 個人成績</h1>

  <div class="filter-box">
    <label>開始日：<input id="startDate" type="date" /></label>
    <label>終了日：<input id="endDate" type="date" /></label>
  </div>
  <button class="main-button" onclick="location.href='index.html'">ホームへ戻る</button>

  <div class="table-wrapper">
    <table id="statsTable">
      <thead>
        <tr>
          <th>プレイヤー</th>
          <th>対局数</th>
          <th>合計ポイント</th>
          <th>1位</th>
          <th>2位</th>
          <th>3位</th>
          <th>4位</th>
          <th>トップ率</th>
          <th>連対率</th>
          <th>ラス回避率</th>
          <th>平均着順</th>
          <th>平均点</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <div id="playerDetail"></div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getFirestore, collection, onSnapshot, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { collection as colSessions } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyBUw-RFVRCQGkEnxy8Uo57Hcer39G0kIUI",
      authDomain: "mahjong-app-2e2e9.firebaseapp.com",
      projectId: "mahjong-app-2e2e9",
      storageBucket: "mahjong-app-2e2e9.appspot.com",
      messagingSenderId: "440425002404",
      appId: "1:440425002404:web:fc5d188d05d4fb26b6fd31",
      measurementId: "G-NP9EELBD7R"
    };
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth();
    signInAnonymously(auth).catch(e => console.error(e.message));
    onAuthStateChanged(auth, user => {
      console.log(user ? `ログイン: ${user.uid}` : "未ログイン");
    });

    let allSessions = [];
    const playersMap = {};
    window.playerData = {};

    async function loadPlayerNames() {
      const snap = await getDocs(collection(db, "players"));
      snap.forEach(doc => { playersMap[doc.data().id] = doc.data().name; });
    }

    document.addEventListener("DOMContentLoaded", async () => {
      await loadPlayerNames();
      onSnapshot(colSessions(db, "sessions"), snap => {
        allSessions = [];
        snap.forEach(doc => allSessions.push({ title: doc.data().title, games: doc.data().games }));
        filterAndCalculate();
      });
      document.getElementById("startDate").addEventListener("change", filterAndCalculate);
      document.getElementById("endDate").addEventListener("change", filterAndCalculate);
    });

    function filterAndCalculate() {
      const start = document.getElementById("startDate").value;
      const end   = document.getElementById("endDate").value;
      const filtered = allSessions.map(s => ({
        ...s,
        games: s.games.filter(g => (!start || g.date >= start) && (!end || g.date <= end))
      })).filter(s => s.games.length > 0);
      filtered.sort((a,b) => new Date(a.title) - new Date(b.title));
      calculateStats(filtered);
      renderTable();
    }

    function calculateStats(sessions) {
      const rankPointMap = {1:50,2:10,3:-10,4:-50};
      const BASE = 30000;
      const pd = {};
      sessions.forEach(sess => {
        sess.games.forEach(game => {
          const sorted = [...game.players].sort((a,b) => b.point - a.point);
          sorted.forEach((p,idx) => {
            if (!pd[p.id]) pd[p.id] = { id:p.id, name:playersMap[p.id]||p.id, games:0, tops:0, seconds:0, thirds:0, fourths:0, totalRank:0, totalPoint:0, pointHistory:[], rankHistory:[], vs:{}, sessionHistory:[], sessionSums:[] };
            const d = pd[p.id];
            const rank = idx+1;
            const rankPt = rankPointMap[rank];
            const rawDiff = p.point - rankPt;
            const finalScore = BASE + rawDiff;
            d.totalPoint += p.point;
            d.totalRank  += rank;
            d.games++;
            d.pointHistory.push(p.point);
            d.rankHistory.push(rank);
            if (rank===1) d.tops++;
            if (rank===2) d.seconds++;
            if (rank===3) d.thirds++;
            if (rank===4) d.fourths++;
            game.players.forEach(op => {
              if (op.id===p.id) return;
              if (!d.vs[op.id]) d.vs[op.id] = { games:0, wins:0, pointDiff:0 };
              d.vs[op.id].games++;
              d.vs[op.id].pointDiff += (p.point - op.point);
              if (p.point > op.point) d.vs[op.id].wins++;
            });
          });
          Object.keys(pd).forEach(pid => {
            const participated = sess.games.some(g => g.players.some(x=>x.id===pid));
            if (participated) pd[pid].sessionHistory.push(sess);
          });
        });
      });
      Object.values(pd).forEach(p=>{
        p.sessionSums = p.sessionHistory.map(sess =>
          sess.games.reduce((acc,gm) => {
            const me = gm.players.find(x=>x.id===p.id);
            return acc + (me? me.point : 0);
          }, 0)
        );
      });
      window.playerData = pd;
    }

    function renderTable() {
      const tbody = document.querySelector("#statsTable tbody");
      tbody.innerHTML = "";
      Object.values(window.playerData).forEach(p=>{
        const avgRank  = (p.totalRank / p.games).toFixed(2);
        const avgPoint = (p.totalPoint / p.games).toFixed(1);
        const topRate  = ((p.tops / p.games) * 100).toFixed(1) + "%";
        const twoRate  = (((p.tops + p.seconds) / p.games) * 100).toFixed(1) + "%";
        const avoidLast= (((p.tops + p.seconds + p.thirds) / p.games) * 100).toFixed(1)+ "%";
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td><span class="clickable-name" data-id="${p.id}">${p.name}</span></td>
          <td>${p.games}</td>
          <td>${p.totalPoint>=0?"+":""}${p.totalPoint.toFixed(1)}</td>
          <td>${p.tops}</td>
          <td>${p.seconds}</td>
          <td>${p.thirds}</td>
          <td>${p.fourths}</td>
          <td>${topRate}</td>
          <td>${twoRate}</td>
          <td>${avoidLast}</td>
          <td>${avgRank}</td>
          <td>${avgPoint}</td>
        `;
        tbody.appendChild(tr);
      });
      applyHighlighting();
      document.querySelectorAll(".clickable-name").forEach(el=>el.addEventListener("click",()=>viewPlayerDetail(el.dataset.id)));
      const first = Object.keys(window.playerData)[0]; if(first) viewPlayerDetail(first);
    }

    function applyHighlighting() {
      const table = document.getElementById("statsTable");
      const rows  = Array.from(table.querySelectorAll("tbody tr"));
      const nCols = table.rows[0].cells.length;
      for (let c=1; c<nCols; c++) {
        let max=-Infinity, min=Infinity;
        rows.forEach(r=>{const v=parseFloat(r.cells[c].textContent); if(!isNaN(v)){max=Math.max(max,v); min=Math.min(min,v);}});
        rows.forEach(r=>{
          const cell = r.cells[c]; const v=parseFloat(cell.textContent);
          cell.classList.remove("highlight-max","highlight-min");
          const hdr = table.rows[0].cells[c].textContent.trim();
          if(!isNaN(v)){
            if(hdr==="平均着順"){ if(v===min) cell.classList.add("highlight-max"); if(v===max) cell.classList.add("highlight-min"); }
            else { if(v===max) cell.classList.add("highlight-max"); if(v===min) cell.classList.add("highlight-min"); }
          }
        });
      }
    }

    window.viewPlayerDetail = function(pid) {
      const p = window.playerData[pid]; if(!p) return;
      const div = document.getElementById("playerDetail"); div.innerHTML = "";
      const avgPoint = (p.totalPoint/p.games).toFixed(1);
      const avgRank  = (p.totalRank/p.games).toFixed(2);
      const topRate  = ((p.tops/p.games)*100).toFixed(1);
      const avoidLast= (((p.tops+p.seconds+p.thirds)/p.games)*100).toFixed(1);
      const maxPt    = Math.max(...p.pointHistory).toFixed(1);
      const minPt    = Math.min(...p.pointHistory).toFixed(1);
      const maxIdx   = p.sessionSums.indexOf(Math.max(...p.sessionSums));
      const minIdx   = p.sessionSums.indexOf(Math.min(...p.sessionSums));
      const maxSes   = p.sessionSums.length&&maxIdx!==-1?`${p.sessionSums[maxIdx].toFixed(1)} pt (${p.sessionHistory[maxIdx].title})`:"-";
      const minSes   = p.sessionSums.length&&minIdx!==-1?`${p.sessionSums[minIdx].toFixed(1)} pt (${p.sessionHistory[minIdx].title})`:"-";
      div.innerHTML = `
        <div class="player-detail">
          <h2>${p.name} の成績詳細</h2>
          <p>🀄 対局数：${p.games} 回<br>🎯 合計ポイント：${p.totalPoint.toFixed(1)} pt<br>📈 平均ポイント：${avgPoint} pt<br>🧮 平均着順：${avgRank} 位<br>👑 トップ率：${topRate}%<br>🚫 ラス回避率：${avoidLast}%<br>🔺 最大獲得pt：${maxPt} pt<br>🔻 最小獲得pt：${minPt} pt<br>📊 最高成績：${maxSes}<br>📉 最低成績：${minSes}<br></p>
          <canvas id="pointChart"></canvas>
          <div class="opponent-section">
            <label>対戦相手を選択：
              <select id="opponentSelect">
                <option value="">--選択してください--</option>
                ${Object.keys(window.playerData[pid].vs).sort().map(opp=>`<option value="${opp}">${playersMap[opp]||opp}</option>`).join('')}
              </select>
            </label>
            <div id="opponentStats"></div>
          </div>
        </div>
      `;
      drawPointGraph(p);
      document.getElementById("opponentSelect").addEventListener("change", e => {
        const vsData = p.vs[e.target.value];
        document.getElementById("opponentStats").innerHTML="";
        renderOpponentStats(vsData);
        drawOpponentGraph(vsData, e.target.value);
      });
    };

    function drawPointGraph(p) {
      const cum = [];
      p.pointHistory.reduce((acc,cur)=>{const next=acc+cur; cum.push(next.toFixed(1)); return next;},0);
      const labels = cum.map((_,i)=>`#${i+1}`);
      const ctx = document.getElementById("pointChart").getContext("2d");
      new Chart(ctx, { type: "line", data: { labels, datasets:[{ label:"累積ポイント推移", data:cum, fill:false, tension:0.1 }]}, options:{responsive:true, scales:{x:{title:{display:true,text:"対局数"}}, y:{title:{display:true,text:"累積ポイント"}}}} });
    }

    // 以下、対戦相手グラフと統計関数（drawOpponentGraph, renderOpponentStats）を追加
    function renderOpponentStats(vsData) {
      const div = document.getElementById("opponentStats");
      if (!vsData) return;
      const total = vsData.games;
      const winRate = ((vsData.wins/total)*100).toFixed(1) + "%";
      const avgDiff = (vsData.pointDiff/total).toFixed(1);
      div.insertAdjacentHTML("afterbegin", `<p>対戦回数：${total}回<br>勝率：${winRate}<br>平均得失点：${avgDiff} pt</p>`);
    }
    function drawOpponentGraph(vsData, oppId) {
      if (!vsData) return;
      const diffs = vsData.pointDiffHistory || [];
      const cum = [];
      diffs.reduce((acc,cur)=>{const n=acc+cur; cum.push(n.toFixed(1)); return n;},0);
      const labels = cum.map((_,i)=>`対戦${i+1}`);
      if (window.oppChart) window.oppChart.destroy();
      let canvas = document.getElementById("pointChartOpponent");
      if (!canvas) {
        document.getElementById("opponentStats").innerHTML += `<canvas id="pointChartOpponent"></canvas>`;
        canvas = document.getElementById("pointChartOpponent");
      }
      const ctx = canvas.getContext("2d");
      window.oppChart = new Chart(ctx, { type:"line", data:{ labels, datasets:[{ label:`${playersMap[oppId]||oppId} との累積得失点`, data:cum, fill:false, tension:0.1 }]}, options:{responsive:true, scales:{x:{title:{display:true,text:"対戦回"}}, y:{title:{display:true,text:"累積得失点"}}}} });
    }
  </script>
</body>
</html>
